# EBNF Grammar for the Caraml Language
# Author: Chubak Bidpaa

## EBNF Conventions
## Terminal, Single-Char   -> '<terminal>'
## Terminal, Multi-Char    -> "<terminal>"
## Repeat zero or more     -> { <non-terminal-or-rule> }
## Repeat once or more     -> <non-terminal-or-rule> { <non-terminal-or-rule> }
## Alternation             -> <non-terminal-or-rule> | <non-terminal-or-rule>
## Optional                -> [ <non-terminal-or-rule> ]
## Range                   -> <terminal> | ... | <terminal>
## Lexical Capture         -> ? <explanation> ?
## Comment                 -> # <comment> or ## <comment>

# The Syntactic Grammar

## Syntactic Grammar Section::A. Expressions and Declarations

module               ::= "module" alnum-identifier "where" toplevel-decls "end"

toplevel-decls       ::= { toplevel-decl }

toplevel-decl        ::= value-decl
                     | type-decl
                     | datatype-decl
                     | infix-decl
                     | import-decl
                     | comment

value-decl           ::= "val" alnum-identifier '=' expr ';'

import-decl          ::= "import" long-identifier ';'

type-decl            ::= "type" alnum-identifier '=' type-exp ';'

datatype-decl        ::= "datatype" alnum-identifier '=' constructor-list ';'
constructor-list     ::= constructor { '|' constructor }
constructor          ::= con-identifier "of" type-exp

expr-list	     ::= expr { ';' expr }

expr                 ::= pattern-list
                     | let-binding
		     | local-binding
                     | "if" expr "then" expr "else" expr
		     | "while" expr "do" expr
		     | "for" expr "do" expr
                     | match-expression
                     | function-expression
                     | "raise" expr
                     | "try" expr "with" match-expression
                     | record-literal
		     | long-identifier "<-" expr
                     | '(' expr ')'

let-binding          ::= "let" [ "rec" ] pattern '=' expr-list [ "in" expr ]

local-binding	     ::= "local" pattern '=' expr-list "in" expr-list  "end"

infix-decl           ::= "infix" [ decimal-digit ] [ identifier ] infix-operator
                     | "infixr" [ decimal-digit ] [ identifier ] infix-operator
                     | "nonfix" infix-operator

match-expression     ::= "match" expr "with" match-clauses "end"
match-clauses        ::= match-clause { '|' match-clause }
match-clause         ::= pattern "->" expr

function-expression  ::= "fun" pattern "->" expr

## Syntactic Grammar Section::B. Type-related Non-terminals

type-exp             ::= type-atom
                     | type-atom "->" type-exp
                     | basic-type
                     | polymorphic-type type-exp
                     | tuple-type

tuple-type           ::= type-exp { '*' type-exp }

type-atom            ::= alnum-identifier
                     | '(' type-exp ')'
                     | type-atom alnum-identifier
                     | record-type

polymorphic-type     ::= "'" alnum-identifier

## Syntactic Grammar Section::C. Record-related Non-terminals

record-type          ::= '{' field-list '}'
field-list           ::= field { ',' field }
field                ::= alnum-identifier ':' type-exp

record-literal       ::= '{' field-bindings '}'
field-bindings       ::= field-binding { ',' field-binding }
field-binding        ::= alnum-identifier '=' expr

## Syntactic Grammar Section::D. Pattern-related Syntactic Non-terminals

pattern              ::= pattern-constructor
                     | identifier-pattern
                     | literal-pattern
                     | wildcard-pattern
                     | list-pattern
		     | inductive-pattern
                     | '(' pattern-list ')'
                     | record-pattern
		     | unit-pattern
		     | restriction-pattern

unit-pattern	     ::= "()"

pattern-constructor  ::= con-identifier pattern-list

pattern-list         ::= pattern-single { '|' pattern-single }
pattern-single       ::= identifier infix-expr
                     | list-pattern

tuple-pattern	     ::= '(' type-xpr  { "::" type-xpr } ')'

list-pattern	     ::= '[' type-expr { "::" type-exp } ']'

record-pattern       ::= '{' field-patterns | field-merge '}'
field-merge          ::= long-identifier '|' field-patterns
field-patterns       ::= field-pattern { ',' field-pattern }
field-pattern        ::= alnum-identifier '=' pattern

restriction-pattern  ::= '(' identifier ':' type-exp ')'

inductive-pattern    ::= identifier { "::" identifier }

identifier-pattern   ::= identifier { identifier }

literal-pattern      ::= integer-literal
                     | string-literal
                     | character-literal

wildcard-pattern     ::= '_'

infix-expr           ::= primary-expr { infix-operator primary-expr }

primary-expr         ::= identifier
                     | literal-value
                     | con-identifier primary-expr
                     | '(' primary-expr ')'
                     | prefix-operator primary-expr

prefix-operator      ::= symb-identifier
infix-operator       ::= [ "op" ] symb-identifier

# Syntactic Grammar Section::E. The main non-terminals

identifier           ::= alnum-identifier
                     | symb-identifier
                     | long-identifier

literal-value        ::= integer-literal
                     | string-literal
                     | character-literal
                     | float-literal
                     | list-literal
                     | tuple-literal

tuple-literal        ::= '(' literal-value { "::" literal-value } ')'

list-literal         ::= '[' list-item-list ']'

list-item-list       ::= list-item { ";;" list-item }

list-item            ::= literal-value
                     | identifier

float-literal        ::= decimal-integer '.' decimal-integer


integer-literal      ::= decimal-integer
                     | octal-integer
                     | hexadecimal-integer
                     | binary-integer

binary-integer       ::= binary-digit { binary-digit } 'B'
octal-integer        ::= octal-digit { octal-digit } 'O'
hexadecimal-integer  ::= hexadecimal-digit { hexadecimal-digit } 'H'
decimal-integer      ::= decimal-digit { decimal-digit }




# The Lexical Grammar

## Lexical Grammar Section::A. Non-terminals for fundemental elements

long-identifier      ::= alnum-identifier { '.' alnum-identifier }
symb-identifier      ::= ( punctuation | letter ) { punctuation | letter | digit }
alnum-identifier     ::= letter { letter | digit | "'" | '_' }
con-identifier       ::= upper-case { letter | digit | "'" | '_' }

character-literal    ::= '#"' ( c-escape-sequence | no-newline ) '"'
c-escape-sequence    ::= '\' ( hex-escape | unicode-escape | c-escape-chars )
hex-escape           ::= 'x' hex-digit [ hex-digit ]
unicode-escape       ::= "U+" hex-digit [ hex-digit [ hex-digit [ hex-digit ] ] ]
c-escape-chars       ::= 'a' | 'b'
                     | 'e' | 'f'
                     | 'n' | 'r'
                     | 't' | 'v'
                     | "'" | '"'


string-literal       ::= '"' { no-double-quote } '"'

binary-digit         ::= '0' | '1'
octal-digit          ::= '0' | '1' | ... | '7'
hexadecimal-digit    ::= decimal-digit | 'A' | ... | 'F' | 'a' | ... | 'f'
decimal-digit        ::= '0' | '1' | ... | '8' | '9'

punctuation          ::= '!' | '"' | '#' | '$'
                     | '%' | '&' | ''' | '(' | ')'
                     | '*' | '+' | ',' | '-' | '.'
                     | '/' | ':' | ';' | '<' | '='
                     | '>' | '?' | '@' | '[' | '\'
                     | ']' | '^' | '_' | '`' | '{'
                     | '|' | '}' | '~'

letter               ::= lower-case | upper-case
lower-case           ::= 'a' | 'b' | ... | 'y' | 'z'
upper-case           ::= 'A' | 'B' | ... | 'Y' | 'Z'

comment              ::= ";;" { no-newline } newline
                     | "(*" { any-char } "*)"

basic-type           ::= "int"
                     | "float"
                     | "char"
                     | "string"
                     | "bool"
                     | "list"
		     | "unit"
		     | "tuple"


## Lexical Grammar Section::B. Descriptive captures

newline              ::= '\n'
no-double-quote      ::= ? any-UTF8-character-except-double-quote ?
no-newline           ::= ? any-UTF8-character-except-newline ?
any-char             ::= ? any-UTF8-character ?


