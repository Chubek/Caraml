# EBNF Grammar for the Caraml Language

## Conventions
## Terminal, Single-Char -> '<terminal>'
## Terminal, Multi-Char  -> "<terminal>"
## Repeat zero or more   -> { <non-terminal-or-rule> }
## Repeat once or more   -> <non-terminal-or-rule> { <non-terminal-or-rule> }
## Alternation	         -> <non-terminal-or-rule> | <non-terminal-or-rule>
## Optional	         -> [ <non-terminal-or-rule> ]
## Range		 -> <terminal> | ... | <terminal>
## Lexical Capture	 -> ? <explanation> ?

# Expressions and declarations, the main crux of the syntactic grammar

module               ::= "module" alnum-identifier "where" toplevel-decls "end"

toplevel-decls       ::= { toplevel-decl }

toplevel-decl        ::= value-decl
                     | type-decl
                     | datatype-decl
                     | infix-decl
                     | import-decl
                     | comment

value-decl           ::= "val" alnum-identifier '=' expr ';'

import-decl          ::= "import" long-identifier ';'

type-decl            ::= "type" alnum-identifier '=' type-exp ';'

datatype-decl        ::= "datatype" alnum-identifier '=' constructor-list ';'
constructor-list     ::= constructor { '|' constructor }
constructor          ::= con-identifier "of" type-exp

expr                 ::= pattern-list
                     | let-binding [ "in" expr ]
                     | "if" expr "then" expr "else" expr
                     | match-expression
                     | function-expression
                     | "raise" expr
                     | "try" expr "with" match-expression
                     | record-literal
                     | '(' expr ')'

let-binding          ::= "let" pattern '=' expr "in" expr

infix-decl           ::= "infix" [ decimal-digit ] [ identifier ] infix-operator
                     | "infixr" [ decimal-digit ] [ identifier ] infix-operator
                     | "nonfix" infix-operator

match-expression     ::= "match" expr "with" match-clauses "end"
match-clauses        ::= match-clause { '|' match-clause }
match-clause         ::= pattern "->" expr

function-expression  ::= "fun" pattern "->" expr

# Type-related syntactic non-terminals

type-exp             ::= type-atom
                     | type-atom "->" type-exp
                     | basic-type
                     | polymorphic-type type-exp
                     | tuple-type

tuple-type           ::= type-exp { '*' type-exp }

type-atom            ::= alnum-identifier
                     | '(' type-exp ')'
                     | type-atom alnum-identifier
                     | record-type

basic-type           ::= "int"
                     | "float"
                     | "char"
                     | "string"
                     | "bool"
                     | "list"

polymorphic-type     ::= "'" alnum-identifier

# Record-related syntactic non-terminals

record-type          ::= '{' field-list '}'
field-list           ::= field { ',' field }
field                ::= alnum-identifier ':' type-exp

record-literal       ::= '{' field-bindings '}'
field-bindings       ::= field-binding { ',' field-binding }
field-binding        ::= alnum-identifier '=' expr

# Pattern-related syntactic non-terminals

pattern              ::= pattern-constructor
                     | identifier-pattern
                     | literal-pattern
                     | wildcard-pattern
                     | list-pattern
                     | '(' pattern-list ')'
                     | record-pattern

pattern-constructor  ::= con-identifier pattern-list

pattern-list         ::= pattern-single { '|' pattern-single }
pattern-single       ::= identifier infix-expr
                     | list-pattern

record-pattern       ::= '{' field-patterns '}'
field-patterns       ::= field-pattern { ',' field-pattern }
field-pattern        ::= alnum-identifier '=' pattern

identifier-pattern   ::= alnum-identifier | long-identifier

literal-pattern      ::= integer-literal
                     | string-literal
                     | character-literal

wildcard-pattern     ::= '_'

infix-expr           ::= primary-expr { infix-operator primary-expr }

primary-expr         ::= identifier
                     | literal-value
                     | con-identifier primary-expr
                     | '(' primary-expr ')'
                     | prefix-operator primary-expr

prefix-operator      ::= symb-identifier
infix-operator       ::= [ "op" ] symb-identifier

# Lexical non-terminals

identifier           ::= alnum-identifier
                     | symb-identifier
                     | long-identifier

long-identifier      ::= alnum-identifier { '.' alnum-identifier }
symb-identifier      ::= ( punctuation | letter ) { punctuation | letter | digit }
alnum-identifier     ::= letter { letter | digit | "'" | '_' }

con-identifier       ::= upper-case { letter | digit | "'" | '_' }

literal-value        ::= integer-literal
                     | string-literal
                     | character-literal
                     | float-literal
                     | list-literal

list-literal         ::= '[' list-item-list ']'

list-item-list       ::= list-item { ";;" list-item }

list-item            ::= literal-value
                     | identifier

float-literal        ::= decimal-integer '.' decimal-integer

character-literal    ::= '#"' ( c-escape-sequence | no-newline ) '"'
c-escape-sequence    ::= '\' ( hex-escape | unicode-escape | c-escape-chars )
hex-escape           ::= 'x' hex-digit [ hex-digit ]
unicode-escape       ::= "U+" hex-digit [ hex-digit [ hex-digit [ hex-digit ] ] ]
c-escape-chars       ::= 'a' | 'b'
                     | 'e' | 'f'
                     | 'n' | 'r'
                     | 't' | 'v'
                     | "'" | '"'

string-literal       ::= '"' { no-double-quote } '"'

integer-literal      ::= decimal-integer
                     | octal-integer
                     | hexadecimal-integer
                     | binary-integer

binary-integer       ::= binary-digit { binary-digit } 'B'
octal-integer        ::= octal-digit { octal-digit } 'O'
hexadecimal-integer  ::= hexadecimal-digit { hexadecimal-digit } 'H'
decimal-integer      ::= decimal-digit { decimal-digit }


# Auxilary lexical non-terminals (not part of the main grammar)

binary-digit         ::= '0' | '1'
octal-digit          ::= '0' | '1' | ... | '7'
hexadecimal-digit    ::= decimal-digit | 'A' | ... | 'F' | 'a' | ... | 'f'
decimal-digit        ::= '0' | '1' | ... | '8' | '9'

punctuation          ::= '!' | '"' | '#' | '$'
                     | '%' | '&' | ''' | '(' | ')'
                     | '*' | '+' | ',' | '-' | '.'
                     | '/' | ':' | ';' | '<' | '='
                     | '>' | '?' | '@' | '[' | '\'
                     | ']' | '^' | '_' | '`' | '{'
                     | '|' | '}' | '~'


letter               ::= lower-case | upper-case
lower-case           ::= 'a' | 'b' | ... | 'y' | 'z'
upper-case           ::= 'A' | 'B' | ... | 'Y' | 'Z'

comment              ::= ";;" { no-newline } newline
                     | "(*" { any-char } "*)"

# Lexical captures

newline              ::= '\n'
no-double-quote      ::= ? any-UTF8-character-except-double-quote ?
no-newline           ::= ? any-UTF8-character-except-newline ?
any-char             ::= ? any-UTF8-character ?

